14/03/2015

Curso Spring senha spring5071 wifi 32249998

Desenvolvimento de uma aplicação que vai ser gravada no banco

Criando a classe produto, no começo usava duas conexões, agora quero usar uma conexão só. A responsabilidae
do produtoDao é só usar a conexão, legal esse pensamento, usar vs. criar, exemplo de desacoplamento da conexão,
passar a conexão pelo construtor é um exemplo de injeção de dependencia. No mercado a injeção de dependencia
é chamada de D.I. , com isso podemos fazer a inversão de controle, com foi feito abaixo, pela injeção
tiramos a criação da conexão do DAO para o TestaProduto.

public class Produto{
	private long id;
	private string nome;
	private double preco;
	private String marca;
	private String descricao;
}

public class ProdutoDao{
	// esse elemento é uma dependencia da classe
	private Connectio conn;
	
	public ProdutoDao(Connection conn){
		//jdbc	
		//this. conn = new ConnectionFactory().getConnection();
		this. conn = conn;
	}

	public long insere(Produto p){
	
	}

	public List<Produto> listar(){
	}
}

public class testaProduto{

	public static void main(){
		// outra versão
		// suponha outra classe ConroladorDeProdutos		
		// injeção de dependencia na mão, veja que vai ficando complexo
		// a injeção de dependencia serve para melhorar toda essa complexidade
		// com injeção de dependencia podemos ir apenas usando as outras 		
		
		//new ProdutoDao(new ControladorDeprodutos (new ConnectionFactory
		//	.getConnection()));
		
		// toda a lógica de criação dos objetos necessários fica dentro do getObject.
		// essas classes que fazem a injeção já foi criada. Por isso usamos o Spring
				
		
		/* sem spring
		ControladorDeProdutos cp = getObject("controlador") // usponha que tem uma classe que te dá um controlador de produtos
 
	

		Connection conn = new ConnectionFactory.getConnection();		

		Produto produto = new Produto();
		
		ProdutoDao produtoDao = new ProdutoDao(conn);
		produtoDao.insere(produto);	
		produtoDao.listar();

		ProdutoAuditDao = new ProdutoAuditDao(conn);
		*/


		//Com Spring
		ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring.xml");
		// nesse momento ele constroi a conexão também
		ProdutoDao dao = context.getBean(ProdutoDao.class); // pode usar o identificador aqui
		
			
	}
}

Freemark thales, sitemesh

Usamos o Spring para controlar a injeção de dependencia e a inversão de controle. Para fazermos a injeção
precisamos configurar o spring previamente, usando um xml. Beans são todas as classes que o spring cuida, se você
quer que o spring cuide de uma classe sua ela deve ser um bean. Abaixo a classe ProdutoDao está sendo gerenciada
pelo spring, o spring precisa de saber quem são dependencias do construtor da classe.

Depois configura o pool de conexões, vamos usar um pool de conexões, DBCP da apache pode ser uma opção, veja
que passamos a referencia de um bean para o outro;

spring.xml esse xmls vai no src do projeto

<beans>

	<bean id="ProdutoDao" class="br.munhra.teste.ProdutoDao"> // usar full qualified name 
		<constructor-args id="DBCP">
	</bean>

	<bean id="DBCP" class="org.xxxx.BasicDataSource">
		<property name="username" value="root" />
		<property name="password" value="" />
		<property name="url" value"jdbc:mysql://localhost/FJ27" />
		<property name="driverClass" value="driver"/>
	</bean>

</beans>

Esse é o modulo do spring conhecido com SpringCore, possui inversão de dependencia e injeção. Para autenticação o spring
tem também o Security, (WS)WebServices, ORM(Mapeamento objeto relacional), JMS(mensagens), MAIL, Transaction (muito boa essa parte) e aparte de MVC

Pensando agora na hora em que o carrinho de compras vai ser fechado, roda no tomcat e no jetty que são mais leves, spring boot é do
spring 4 foi lançado no meio de 2014

- Autenticar
- Chamda a um serviço WEB
- Baixar o Estoque
- Notificar CD
- Disparar email
- Controlar a transação

Fazer uma aplicação web usando o spring usamos o spring MVC, quando usamos servlets a parte ruim misturar codigo java com html
evitar de ficar usando request.getParameter(), para evitar misturar codigo java com html

Sai do browser, vai para o servidor e encontra um servlet e depois faz uma chamada para o Dao depois para uma pagina JSP. Esse
fluxo já é um MVC. Modelo é o produto, Controller é o servlet e a view é o JSP.

Acessar a aplicação em http://localhost:8080/estoque/oi em spring, vamos fazer o spring chamar a classe OiController teria que escrever
no xml, mas vamos usar uma anotação chamada @Controller

Spring é um actionbased framework

Bug F5

metodos do form são get and post o post esconde os parametros

Formato de url unfriendly
produto/detalhe?id=1
Format friendly
produto/1

@Controller
public class OiController(){

	@RequestMapping("oi")// coloca a url que vai mapear	
	public String void oi(){
		//return "/WEB-INF/jsps/oi.jsp";
		return "oi.jsp" // feito a configuração o prefixo já esta definido podemos mecher na extenção	
	}
}

//view
//para o jsp não ficar visivel  para o usuario guarda na pasta web-inf, e o usuario vai ter que acessar pelo controller
oi.jsp
<h1>Ola Spring<h1>

spring.xml // para ser anotation

<beans>
	<mvc:annotation-based /> // muda o spring para pegar as anotações
	<context:component-scan base-package="br.com.caelum.estoque"/>
	
	<bean class="org.spring.framework.InternalResourceViewResolver">
		<propertyName="prefix" value="/WEB-INF/JSPS/">	
		<propertyName="sufix"  value=".jsp">
	</bean>
	
</beans>


Vamos agora exibir a lista de produto no jsp

@Component // aqui o spring vai gerenciar o objeto, como se tivesse marcado no xml
public class ProdutoDao{

}

@Controller
@RequestMapping("/produto")
public class ProdutoController{

	private ProdutoDao produtoDao;
		   // pode anotar tanto o atributo quanto o construtor, foi preferido colocar no construtor
		   // para mostrar a dependencia clara, o autowired diz ao spring que ele deve injetar uma instancia
		   // do objeto ProdutoDao
	@Autowired	
	public ProdutoController(ProdutoDao produtoDao){
		this.produtoDao = produtoDao; 
	}

	@RequestMapping("/listar")	
	public ModelAndView lista(){
		
		List<Produto> lista = produtoDao.listar();	
		// agora precisa passar a lista para a view
		ModelAndView mv = new ModelAndView("Lista-Produtos"); // ModelAndView faz a ponte entre o modelo e a view
		mv.addAttribute("produtos",lista);
		// o literal produtos do parametro acima vai ser usado na view para pegar a lista
			
		return mv;		
	}
	//@RequestMapping("/detalhe/{id}") // agora aceita o friendly
	@RequestMapping("/detalhe") //parametro id com o mesmo nome faz o binding da url
	//public ModelAndView detalhes(@PathVariable Long id){ //agora muda para fazer o binding da notação friendly	
	public ModelAndView detalhes(Long id){
		Produto produto = dao.buscaPorId(id);
		ModelAndView mv = new ModelAndView("/detalhes");
		mv.addAttribute(produto)
		return mv
	}

	@RequestMapping(value="/salvar",method=Reques..Post) // vai salvar usando uma convenção de nomes só quando for post	
	public void string salvar(Produto produto){
		dao.salvar(produto);
		//return "/lista"; // tem que fazer o spring redirencionar para carregar a lista
		return "redirect:/produto/lista" 	
	}
}

detalhes.jsp
<html>
	Nome: ${produto.nome} <br/>
	Descricao: ${produto.descricao} <br/>
	Quantidade: ${produto.quantidade} <br/>
</html>

lista-produtos.jsp (usa expression language para pegar os dados)

<table>
	
	<c:forEach items="produtos" var="produto"> // produtos vem lá do ModelAndView
	<tr>
		<td>
			<a href="produto/detalhe?id=${produto.id}>
				Detalhes
			</a>
		</td>
	</tr>

</table>


cadastro.jsp

<form action="produto/salvar" method="POST"> // caminho do submit
	Nome <input type="text" name="nome"/>
	Descrição <input type="text" name="descricao"/>
	Quantidade <input type="text" name="quantidade"/>
	<input type="submit" value="Cadastrar"/>
</form>





